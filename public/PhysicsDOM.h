#ifndef PHYSICSDOM_H
#define PHYSICSDOM_H

// CreateDOM: Schema Generation tool written by John W. Ratcliff, 2017
// Warning:This source file was auto-generated by the CreateDOM tool. Do not try to edit this source file manually!
// The Google DOCs Schema Spreadsheet for this source came from: https://docs.google.com/spreadsheets/d/118I5kdu2XT-6wfCG044937xfEKDyX2oNg04G8Wqi6o0/edit?usp=sharing

#include <stdint.h>


namespace PHYSICS_DOM
{


// Defines a basic 3d vector type
class Vec3
{
public:
	// Declare the constructor.
	Vec3() { }

	// Declare the assignment constructor.
	Vec3(const float &_x,const float &_y,const float &_z)
	{
		x = _x;
		y = _y;
		z = _z;
	}

	float  		x{ 0 }; 											// x axis component of the vector
	float  		y{ 0 }; 											// y axis component of the vector
	float  		z{ 0 }; 											// z axis component of the vector
};


// Defines a basic quaternion data type
class Quat
{
public:
	// Declare the constructor.
	Quat() { }

	// Declare the assignment constructor.
	Quat(const float &_x,const float &_y,const float &_z,const float &_w)
	{
		x = _x;
		y = _y;
		z = _z;
		w = _w;
	}

	float  		x{ 0 }; 											// 
	float  		y{ 0 }; 											// 
	float  		z{ 0 }; 											// 
	float  		w{ 1 }; 											// 
};


// Defines a basic plane equation
class Plane
{
public:
	// Declare the constructor.
	Plane() { }

	// Declare the assignment constructor.
	Plane(const Vec3 &_n,const float &_d)
	{
		n = _n;
		d = _d;
	}

	Vec3 		n{ 0,1,0 };   										// Normal of the plane equation
	float  		d{ 0 }; 											// The distance from the origin of the plane 
};


// Defines a transform; position and rotation as a quaternion
class Pose
{
public:
	// Declare the constructor.
	Pose() { }

	// Declare the assignment constructor.
	Pose(const Quat &_q,const Vec3 &_p)
	{
		q = _q;
		p = _p;
	}

	Quat 		q;  													// Quaternion rotation
	Vec3 		p;  													// Origin position of the pose
};


// Defines an axis aligned bounding box
class Bounds3
{
public:
	// Declare the constructor.
	Bounds3() { }

	// Declare the assignment constructor.
	Bounds3(const Vec3 &_bmin,const Vec3 &_bmax)
	{
		bmin = _bmin;
		bmax = _bmax;
	}

	Vec3 		bmin; 												// Minimum axis of bounding box
	Vec3 		bmax; 												// Maximum axis of bounding box
};


// Defines the type of node we are dealing with
enum NodeType
{
	NT_NODE, 							// The base Node class
	NT_PHYSICS_MATERIAL, 				// A physics material
	NT_GEOMETRY_INSTANCE,  				// Defines an instance of a geometry
	NT_TRIANGLEMESH, 					// Defines the contents of a triangle mesh
	NT_CONVEXHULL ,						// Defines the contents of a convex hull
	NT_HEIGHTFIELD , 					// Defines the contents of a heightfield
	NT_RIGID_BODY,   					// Common properties of both static and dynamic rigid bodies
	NT_RIGID_STATIC, 					// A static rigid body
	NT_RIGID_DYNAMIC,  					// A dynamic rigid body
	NT_BODY_PAIR_FILTERS,  				// A node representing a collection of body pair filters
	NT_JOINT,  							// Base class for a joint
	NT_FIXED_JOINT,						// A fixed joint
	NT_SPHERICAL_JOINT,					// A spherical joint
	NT_HINGE_JOINT,						// A hinge joint
	NT_PRISMATIC_JOINT,					// A prismatic joint
	NT_DISTANCE_JOINT,   				// A distance joint
	NT_BALL_AND_SOCKET_JOINT,  			// A ball and socket joint
	NT_D6_JOINT, 						// A six degree of freedom joint
	NT_INSTANCE_COLLECTION,				// Instantiates a collection of nodes
	NT_COLLECTION,   					// Defines a collection of nodes
	NT_SCENE,  							// Defines a collection that gets instantiated on startup into a physics scene
};


// Defines an optional visual mesh binding to a physics node
class VisualBinding
{
public:
	const char * visualName{ nullptr };							// Name of associated visual mesh
	Pose 		localPose;  											// Local relative pose of visual mesh to corresponding physics node
	Vec3 		localScale;   										// Local relative scale of visual mesh to corresponding physics node
};


// Describes a key-value pair for custom properties on a node
class KeyValuePair
{
public:
	const char * key{ nullptr }; 								// They 'key' identifier; what this property is
	const char * value{ nullptr };   							// The value of this property; up to each the user to figure out how to interpret each property relative to the keyword
};


// A collection of key/value pair properties relative to a particular category
class AdditionalProperties
{
public:
	const char * category{ nullptr };  							// The category this set of key/value pairs is associated with (example 'physx', 'mujoco', etc.
	uint32_t 	keyValuePairsCount { 0 };
	KeyValuePair*  keyValuePairs{ nullptr }; 					// The array of key/value pairs associated with this category
};


// Base class that specifies a unique ID and an optional description name field for an object
class Node
{
public:
	const char * id{ nullptr };									// Unique Id for this object
	const char * name{ nullptr };  								// Optional name for this object
	NodeType 	type{ NT_NODE };   								// The type of node
	VisualBinding  visual;   									// Optional visual bindings for this node; for exaple some physics components have a corresponding named graphics component
	uint32_t 	additionalPropertiesCount { 0 };
	AdditionalProperties* additionalProperties{ nullptr };   	// An optional set of properties for this node; a set of key-value pairs for each application/engine specific category
};


// ShortDescription
class MeshScale
{
public:
	Vec3 		scale;  												// Scale of the mesh on the X,Y,Z axes
	Quat 		rotation; 											// Orientation of the mesh as a quaternion
};


// Defines the physical material properties of a surface
class PhysicsMaterial : public Node
{
public:
	// Declare the constructor.
	PhysicsMaterial()
	{
		Node::type = NT_PHYSICS_MATERIAL;
	}

	bool 		disableFriction{ false }; 							// If true, then friction is disabled for the material
	bool 		disableStrongFriction{ false };   					// If true then strong friction is disabled for the material
	float  		dynamicFriction{ 0.5f };  							// The coefficient of dynamic friction.
	float  		staticFriction{ 0.5f }; 							// The coefficient of static friction
	float  		restitution{ 0.5f };  								// The coefficient of resitution.
};


// Describes the data for a convex hull
class ConvexHull : public Node
{
public:
	// Declare the constructor.
	ConvexHull()
	{
		Node::type = NT_CONVEXHULL;
	}

	uint32_t 	pointsCount { 0 };
	Vec3*  		points{ nullptr };									// Array of data points describing the convex hull
};


// Describes the data for a triangle mesh
class TriangleMesh : public Node
{
public:
	// Declare the constructor.
	TriangleMesh()
	{
		Node::type = NT_TRIANGLEMESH;
	}

	uint32_t 	pointsCount { 0 };
	Vec3*  		points{ nullptr };									// Array of vertices for the triangle mesh
	uint32_t 	trianglesCount { 0 };
	uint32_t*  	triangles{ nullptr };  							// Array of triangle indices
	uint32_t 	materialIndicesCount { 0 };
	uint8_t* 	materialIndices{ nullptr };  						// Optional per-triangle material index
};


// The data for a heighfield; as 2d array of 32 bit samples; 16 bits for height, 16 bits for material indices, holes, and other metadata
class HeightField : public Node
{
public:
	// Declare the constructor.
	HeightField()
	{
		Node::type = NT_HEIGHTFIELD;
	}

	uint32_t 	rowCount{ 0 }; 									// Number of sample rows in the height field samples array.
	uint32_t 	columnCount{ 0 };									// Number of sample columns in the height field samples array.
	uint32_t 	samplesCount { 0 };
	uint16_t*  	samples{ nullptr };								// Heightfield sample data
	uint32_t 	metaDataCount { 0 };
	uint16_t*  	metaData{ nullptr }; 							// Optional meta data for each sample; determines per sample material, winding order, and whether or not to treat it as a hole
};


enum GeometryType
{
	GT_BOX_GEOMETRY, 					// A basic sphere primitive
	GT_SPHERE_GEOMETRY,					// A plane 
	GT_CAPSULE_GEOMETRY, 				// A capsule
	GT_PLANE_GEOMETRY,   				// A simple box primitive
	GT_CYLINDER_GEOMETRY,  				// A cylinder 
	GT_CONVEXHULL_GEOMETRY,				// A convex hull geometry
	GT_TRIANGLEMESH_GEOMETRY,  			// A triangle mesh (can only be static, not dynamic)
	GT_HEIGHTFIELD_GEOMETRY, 			// A heightfield (can only be static, not dynamic)
};


// Base class for all geometries
class Geometry
{
public:
	GeometryType type;   										// 
};


// Defines a box geometry
class BoxGeometry : public Geometry
{
public:
	// Declare the constructor.
	BoxGeometry()
	{
		Geometry::type = GT_BOX_GEOMETRY;
	}

	Vec3 		dimensions{ 1,1,1 };									// Dimensions of the box
};


// Defines a sphere geometry
class SphereGeometry : public Geometry
{
public:
	// Declare the constructor.
	SphereGeometry()
	{
		Geometry::type = GT_SPHERE_GEOMETRY;
	}

	float  		radius{ 1 };  										// The radius of the sphere
};


// Defines a capsule geometry
class CapsuleGeometry : public Geometry
{
public:
	// Declare the constructor.
	CapsuleGeometry()
	{
		Geometry::type = GT_CAPSULE_GEOMETRY;
	}

	float  		radius{ 1 };  										// The radius of the capsule
	float  		height{ 1 };  										// The height of the capsule
};


// Defines a cylinder geometry
class CylinderGeometry : public Geometry
{
public:
	// Declare the constructor.
	CylinderGeometry()
	{
		Geometry::type = GT_CYLINDER_GEOMETRY;
	}

	float  		radius{ 1 };  										// The radius of the cylinder
	float  		height{ 1 };  										// The height of the cylinder
};


// Defines a convex mesh geometry
class ConvexHullGeometry : public Geometry
{
public:
	// Declare the constructor.
	ConvexHullGeometry()
	{
		Geometry::type = GT_CONVEXHULL_GEOMETRY;
	}

	MeshScale  	scale;   										// The scale to apply to this convex mesh
	const char * convexMesh{ nullptr };							// The name of the convex mesh asset
};


// Defines a triangle mesh geometry
class TriangleMeshGeometry : public Geometry
{
public:
	// Declare the constructor.
	TriangleMeshGeometry()
	{
		Geometry::type = GT_TRIANGLEMESH_GEOMETRY;
	}

	MeshScale  	scale;   										// The scale of the triangle mesh
	const char * triangleMesh{ nullptr };  						// The name of the triangle mesh asset
	bool 		doubleSided{ false }; 								// Whether or not this triangle mesh should be treated as double sided for collision detection
};


// Defines a heightfield geometry
class HeightFieldGeometry : public Geometry
{
public:
	// Declare the constructor.
	HeightFieldGeometry()
	{
		Geometry::type = GT_HEIGHTFIELD_GEOMETRY;
	}

	const char * heightField{ nullptr }; 						// The id of the heightfield data asset
	float  		heightScale{ 1 };   								// The scaling factor for the height field in vertical direction (y direction in local space).
	float  		rowScale{ 1 };										// The scaling factor for the height field in the row direction (x direction in local space).
	float  		columnScale{ 1 };   								// The scaling factor for the height field in the column direction (z direction in local space).
	bool 		doubleSided{ false }; 								// Whether or not this heighfield should be treated as double sided for collision detection
};


// Defines a plane equation geometry (position and orientation of the plane come from the geometry instance)
class PlaneGeometry : public Geometry
{
public:
	// Declare the constructor.
	PlaneGeometry()
	{
		Geometry::type = GT_PLANE_GEOMETRY;
	}

};


// Defines a single instance of a geometry
class GeometryInstance
{
public:
	Geometry 	*geometry{ nullptr };								// The geometry associated with this instance
	uint32_t 	materialsCount { 0 };
	const char **  materials{ nullptr }; 						// Id of physical material(s) associated with this geometry instance (usually one material; but for heightifields and triangle meshes can be more than one)
	Pose 		localPose;  											// The local pose for this geometry instance
	const char * collisionFilterSettings{ nullptr }; 			// Describes collision filtering settings; what other types of objects this object will collide with
};


// Defines the common properties for a rigid body
class RigidBody : public Node
{
public:
	// Declare the constructor.
	RigidBody()
	{
		Node::type = NT_RIGID_BODY;
	}

	uint32_t 	geometryInstancesCount { 0 };
	GeometryInstance** geometryInstances{ nullptr }; 			// The set of geometries to instance with this actor
	Pose 		globalPose;   										// The global pose for this actor
};


// Defines a static rigid body
class RigidStatic : public RigidBody
{
public:
	// Declare the constructor.
	RigidStatic()
	{
		Node::type = NT_RIGID_STATIC;
	}

};


// Defines a dynamic rigid body
class RigidDynamic : public RigidBody
{
public:
	// Declare the constructor.
	RigidDynamic()
	{
		Node::type = NT_RIGID_DYNAMIC;
	}

	bool 		disableGravity{ false };								// Disables scene gravity for this actor
	Pose 		centerOfMassLocalPose;  								// Center of mass and local pose
	float  		mass{ 1 };											// Sets the mass of a dynamic actor.
	Vec3 		massSpaceInertiaTensor{ 1,1,1 };						// Sets the inertia tensor, using a parameter specified in mass space coordinates.
	Vec3 		linearVelocity{ 0,0,0 };								// Sets the linear velocity of the actor.
	Vec3 		angularVelocity{ 0,0,0 }; 							// Sets the angular velocity of the actor.
	float  		linearDamping{ 0 }; 								// Sets the linear damping coefficient.
	float  		angularDamping{ 0.05f };  							// Sets the angular damping coefficient.
	float  		maxAngularVelocity{ 7 };  							// set the maximum angular velocity permitted for this actor.
	bool 		kinematic{ false };   								// If true this is a dynamic object; but currently kinematically controlled
};


// Defines the common properties for a joint
class Joint : public Node
{
public:
	// Declare the constructor.
	Joint()
	{
		Node::type = NT_JOINT;
	}

	const char * body0{ nullptr };   							// Id of first rigid body joint is constrained to; if empty string; then constaint to the world
	const char * body1{ nullptr };   							// Id of the second rigid body the joint is constrainted to
	Pose 		localpose0;   										// The parent relative pose; relative to body0
	Pose 		localpose1;   										// The parent relative pose; relative to body1
	bool 		collisionEnabled{ false };  							// 
};


// Defines the properties specific to a fixed joint 
// Not all properties yet defined!
class FixedJoint : public Joint
{
public:
	// Declare the constructor.
	FixedJoint()
	{
		Joint::type = NT_FIXED_JOINT;
	}

};


// Defines the properties specific to a spherical joint 
// Not all properties yet defined!
class SphericalJoint : public Joint
{
public:
	// Declare the constructor.
	SphericalJoint()
	{
		Joint::type = NT_SPHERICAL_JOINT;
	}

	float  		limitY{ 0 };  										// The limit angle (in radians) for the y rotation axis
	float  		limitZ{ 0 };  										// The limit angle (in radians) for the z rotation axis
};


// Defines the properties specific to a revolute joint 
// Not all properties yet defined!
class HingeJoint : public Joint
{
public:
	// Declare the constructor.
	HingeJoint()
	{
		Joint::type = NT_HINGE_JOINT;
	}

	float  		limtLow{ 0 };   									// The lower limit of the hinge joint in radians
	float  		limitHigh{ 0 }; 									// The upper limit of the hinge joint in radians
};


// Defines the properties specific to a prismatic joint 
// Not all properties yet defined!
class PrismaticJoint : public Joint
{
public:
	// Declare the constructor.
	PrismaticJoint()
	{
		Joint::type = NT_PRISMATIC_JOINT;
	}

	float  		limitLow{ 0 };										// The lower linear limit distance
	float  		limitHigh;											// The upper linear limit distance
};


// Defines the properties specific to a distance joint 
// Not all properties yet defined!
class DistanceJoint : public Joint
{
public:
	// Declare the constructor.
	DistanceJoint()
	{
		Joint::type = NT_DISTANCE_JOINT;
	}

	float  		distanceLow{ 0 };   								// The minimum distance allowed between the two bodies
	float  		distanceHigh{ 0 };									// The maximum distance allowed between the two bodies
};


// Defines the properties specific to a ball and socket joint 
// Not all properties yet defined!
class BallAndSocketJoint : public Joint
{
public:
	// Declare the constructor.
	BallAndSocketJoint()
	{
		Joint::type = NT_BALL_AND_SOCKET_JOINT;
	}

	float  		limitXLow{ 0 }; 									// The lower angle limit, in radians, for the X rotation axis
	float  		limitXHigh{ 0 };  									// The upper angle limit, in radians, for the X rotation axis
	float  		limitY{ 0 };  										// The limit angle (in radians) for the y rotation axis
	float  		limitZ{ 0 };  										// The limit angle (in radians) for the z rotation axis
};


// Defines the properties specific to a six degree of freedom joint 
// Not all properties yet defined!
class D6Joint : public Joint
{
public:
	// Declare the constructor.
	D6Joint()
	{
		Joint::type = NT_D6_JOINT;
	}

};


// Defines two bodies, by id, that should not collide with each other
class BodyPairFilter
{
public:
	const char * bodyA{ nullptr };   							// Id of first body
	const char * bodyB { nullptr };								// Id of second body
};


// A collection of body pair filters
class BodyPairFilters : public Node
{
public:
	// Declare the constructor.
	BodyPairFilters()
	{
		Node::type = NT_BODY_PAIR_FILTERS;
	}

	uint32_t 	bodyPairsCount { 0 };
	BodyPairFilter* bodyPairs{ nullptr };  						// Array of body pair filters
};


class InstanceCollection : public Node
{
public:
	// Declare the constructor.
	InstanceCollection()
	{
		Node::type = NT_INSTANCE_COLLECTION;
	}

	const char * collection{ nullptr };							// Name of collection to instance
	Pose 		pose; 												// Pose to instance collection at
	Vec3 		scale;  												// Scale of instance
};


// A collection of nodes
class Collection : public Node
{
public:
	// Declare the constructor.
	Collection()
	{
		Node::type = NT_COLLECTION;
	}

	uint32_t 	nodesCount { 0 };
	Node**   	nodes{ nullptr };									// Array of nodes in this collection
};


// A special type of 'collection' which is instantiated on startup
class Scene : public Node
{
public:
	// Declare the constructor.
	Scene()
	{
		Node::type = NT_SCENE;
	}

	Vec3 		gravity{ 0.0f,-9.8f,0.0f };   						// Gravity
	uint32_t 	nodesCount { 0 };
	Node**   	nodes{ nullptr };									// Array of nodes in this collection
};


// The root node container
class PhysicsDOM
{
public:
	uint32_t 	collectionsCount { 0 };
	Collection** collections{ nullptr }; 						// The array of top level collections
	uint32_t 	scenesCount { 0 };
	Scene**		scenes{ nullptr };									// The array of top level scenes; a scene is instantiated into the physics simulation
};



} // End of PHYSICS_DOM namespace

#endif // End of Scene
