#ifndef PHYSICSDOM_IMPL_H
#define PHYSICSDOM_IMPL_H

// CreateDOM: Schema Generation tool written by John W. Ratcliff, 2017
// Warning:This source file was auto-generated by the CreateDOM tool. Do not try to edit this source file manually!
// The Google DOCs Schema Spreadsheet for this source came from: https://docs.google.com/spreadsheets/d/118I5kdu2XT-6wfCG044937xfEKDyX2oNg04G8Wqi6o0/edit?usp=sharing

#include "PhysicsDOM.h"
#include <string>
#include <vector>
#include <stdint.h>


namespace PHYSICS_DOM
{


// Forward declare the two types of string vector containers.
typedef std::vector< std::string > StringVector;
typedef std::vector< const char * > ConstCharVector;

// Declare the clone-object class for deep copies
// of objects by the implementation classes
// Not to be used with the base DOM classes;
// they do not support deep copies
// Also declares the virtual method to init the DOM contents.
class CloneObject
{
public:
	// Declare the default virtual clone method; not implemented for DOM objects; only used for the implementation versions.
	virtual CloneObject *clone(void) const { return nullptr; };
	// Declare the default initDOM method; which is only needed for some implementation objects.
	virtual void initDOM(void) {  };
};

// Defines an optional visual mesh binding to a physics node
class VisualBindingImpl: public CloneObject
{
public:

	// Declare the constructor.
	VisualBindingImpl() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	VisualBindingImpl(const VisualBindingImpl &other)
	{
		*this = other;
	}


	virtual VisualBinding * getVisualBinding(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new VisualBindingImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	VisualBindingImpl& operator=(const VisualBindingImpl& other)
	{
		if (this != &other )
		{
			mVisualName = other.mVisualName;
			mLocalPose = other.mLocalPose;
			mLocalScale = other.mLocalScale;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.visualName = mVisualName.c_str(); // Assign the current string pointer.
		mDOM.localPose = mLocalPose; // Simple member variable assignment to the DOM reflection: localPose
		mDOM.localScale = mLocalScale; // Simple member variable assignment to the DOM reflection: localScale
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	VisualBindingImpl(VisualBindingImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	VisualBindingImpl& operator=(VisualBindingImpl&& other)
	{
		if (this != &other )
		{
			mVisualName = other.mVisualName;
			mLocalPose = other.mLocalPose;
			mLocalScale = other.mLocalScale;
		}
		return *this;
	}

	std::string	mVisualName; 									// Name of associated visual mesh
	Pose 		mLocalPose;   										// Local relative pose of visual mesh to corresponding physics node
	Vec3 		mLocalScale;											// Local relative scale of visual mesh to corresponding physics node
private:
	VisualBinding  mDOM; // Declare the DOM version.
};


// Describes a key-value pair for custom properties on a node
class KeyValuePairImpl: public CloneObject
{
public:

	// Declare the constructor.
	KeyValuePairImpl() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	KeyValuePairImpl(const KeyValuePairImpl &other)
	{
		*this = other;
	}


	virtual KeyValuePair * getKeyValuePair(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new KeyValuePairImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	KeyValuePairImpl& operator=(const KeyValuePairImpl& other)
	{
		if (this != &other )
		{
			mKey = other.mKey;
			mValue = other.mValue;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.key = mKey.c_str(); // Assign the current string pointer.
		mDOM.value = mValue.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	KeyValuePairImpl(KeyValuePairImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	KeyValuePairImpl& operator=(KeyValuePairImpl&& other)
	{
		if (this != &other )
		{
			mKey = other.mKey;
			mValue = other.mValue;
		}
		return *this;
	}

	std::string	mKey;  											// They 'key' identifier; what this property is
	std::string	mValue;											// The value of this property; up to each the user to figure out how to interpret each property relative to the keyword
private:
	KeyValuePair mDOM; // Declare the DOM version.
};

typedef std::vector< KeyValuePairImpl > KeyValuePairVectorImpl; // Forward declare the 'KeyValuePair' vector
typedef std::vector< KeyValuePair > KeyValuePairVectorDOM; // Forward declare the 'KeyValuePair' vector

// A collection of key/value pair properties relative to a particular category
class AdditionalPropertiesImpl: public CloneObject
{
public:

	// Declare the constructor.
	AdditionalPropertiesImpl() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	AdditionalPropertiesImpl(const AdditionalPropertiesImpl &other)
	{
		*this = other;
	}


	virtual AdditionalProperties * getAdditionalProperties(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new AdditionalPropertiesImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	AdditionalPropertiesImpl& operator=(const AdditionalPropertiesImpl& other)
	{
		if (this != &other )
		{
			mCategory = other.mCategory;
			mKeyValuePairs = other.mKeyValuePairs;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.category = mCategory.c_str(); // Assign the current string pointer.
		mDOM.keyValuePairsCount = uint32_t(mKeyValuePairsDOM.size()); // assign the number of items in the array.
		mDOM.keyValuePairs = mDOM.keyValuePairsCount ? &mKeyValuePairsDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	AdditionalPropertiesImpl(AdditionalPropertiesImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	AdditionalPropertiesImpl& operator=(AdditionalPropertiesImpl&& other)
	{
		if (this != &other )
		{
			mCategory = other.mCategory;
			mKeyValuePairs = other.mKeyValuePairs;
		}
		return *this;
	}

	std::string	mCategory;   									// The category this set of key/value pairs is associated with (example 'physx', 'mujoco', etc.
	KeyValuePairVectorImpl mKeyValuePairs;   					// The array of key/value pairs associated with this category
private:
	AdditionalProperties mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	KeyValuePairVectorDOM mKeyValuePairsDOM; // Scratch array for const char pointers.
};

typedef std::vector< AdditionalPropertiesImpl > AdditionalPropertiesVectorImpl; // Forward declare the 'AdditionalProperties' vector
typedef std::vector< AdditionalProperties > AdditionalPropertiesVectorDOM; // Forward declare the 'AdditionalProperties' vector

// Base class that specifies a unique ID and an optional description name field for an object
class NodeImpl: public CloneObject
{
public:

	// Declare the constructor.
	NodeImpl() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	NodeImpl(const NodeImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new NodeImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	NodeImpl& operator=(const NodeImpl& other)
	{
		if (this != &other )
		{
			mId = other.mId;
			mName = other.mName;
			mType = other.mType;
			mVisual = other.mVisual;
			mAdditionalProperties = other.mAdditionalProperties;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.id = mId.c_str(); // Assign the current string pointer.
		mDOM.name = mName.c_str(); // Assign the current string pointer.
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		{
			VisualBindingImpl *impl = static_cast< VisualBindingImpl *>(&mVisual); // static cast to the implementation class.
			impl->initDOM(); // Initialize DOM components of member variable.
			mDOM.visual = *impl->getVisualBinding(); // Copy the DOM struct values.
		}
		mDOM.additionalPropertiesCount = uint32_t(mAdditionalPropertiesDOM.size()); // assign the number of items in the array.
		mDOM.additionalProperties = mDOM.additionalPropertiesCount ? &mAdditionalPropertiesDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	NodeImpl(NodeImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	NodeImpl& operator=(NodeImpl&& other)
	{
		if (this != &other )
		{
			mId = other.mId;
			mName = other.mName;
			mType = other.mType;
			mVisual = other.mVisual;
			mAdditionalProperties = other.mAdditionalProperties;
		}
		return *this;
	}

	std::string	mId; 											// Unique Id for this object
	std::string	mName;   										// Optional name for this object
	NodeType 	mType{ NT_NODE };									// The type of node
	VisualBindingImpl mVisual;   								// Optional visual bindings for this node; for exaple some physics components have a corresponding named graphics component
	AdditionalPropertiesVectorImpl mAdditionalProperties;  		// An optional set of properties for this node; a set of key-value pairs for each application/engine specific category
private:
	Node 		mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	AdditionalPropertiesVectorDOM mAdditionalPropertiesDOM; // Scratch array for const char pointers.
};


// Defines the physical material properties of a surface
class PhysicsMaterialImpl : public NodeImpl
{
public:
	// Declare the constructor.
	PhysicsMaterialImpl()
	{
		NodeImpl::mType = NT_PHYSICS_MATERIAL;
	}


	// Declare the virtual destructor.
	virtual ~PhysicsMaterialImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PhysicsMaterialImpl(const PhysicsMaterialImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	PhysicsMaterial * getPhysicsMaterial(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new PhysicsMaterialImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	PhysicsMaterialImpl& operator=(const PhysicsMaterialImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			mDisableFriction = other.mDisableFriction;
			mDisableStrongFriction = other.mDisableStrongFriction;
			mDynamicFriction = other.mDynamicFriction;
			mStaticFriction = other.mStaticFriction;
			mRestitution = other.mRestitution;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.disableFriction = mDisableFriction; // Simple member variable assignment to the DOM reflection: disableFriction
		mDOM.disableStrongFriction = mDisableStrongFriction; // Simple member variable assignment to the DOM reflection: disableStrongFriction
		mDOM.dynamicFriction = mDynamicFriction; // Simple member variable assignment to the DOM reflection: dynamicFriction
		mDOM.staticFriction = mStaticFriction; // Simple member variable assignment to the DOM reflection: staticFriction
		mDOM.restitution = mRestitution; // Simple member variable assignment to the DOM reflection: restitution
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PhysicsMaterialImpl(PhysicsMaterialImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PhysicsMaterialImpl& operator=(PhysicsMaterialImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mDisableFriction = other.mDisableFriction;
			mDisableStrongFriction = other.mDisableStrongFriction;
			mDynamicFriction = other.mDynamicFriction;
			mStaticFriction = other.mStaticFriction;
			mRestitution = other.mRestitution;
		}
		return *this;
	}

	bool 		mDisableFriction{ false };  							// If true, then friction is disabled for the material
	bool 		mDisableStrongFriction{ false };						// If true then strong friction is disabled for the material
	float  		mDynamicFriction{ 0.5f };   						// The coefficient of dynamic friction.
	float  		mStaticFriction{ 0.5f };  							// The coefficient of static friction
	float  		mRestitution{ 0.5f };   							// The coefficient of resitution.
private:
	PhysicsMaterial mDOM; // Declare the DOM version.
};

typedef std::vector< Vec3 > Vec3VectorImpl; // Forward declare the 'Vec3' vector

// Describes the data for a convex hull
class ConvexHullImpl : public NodeImpl
{
public:
	// Declare the constructor.
	ConvexHullImpl()
	{
		NodeImpl::mType = NT_CONVEXHULL;
	}


	// Declare the virtual destructor.
	virtual ~ConvexHullImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	ConvexHullImpl(const ConvexHullImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	ConvexHull * getConvexHull(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new ConvexHullImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	ConvexHullImpl& operator=(const ConvexHullImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			mPoints = other.mPoints;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.pointsCount = uint32_t(mPoints.size()); // assign the number of items in the array.
		mDOM.points = mDOM.pointsCount ? &mPoints[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	ConvexHullImpl(ConvexHullImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	ConvexHullImpl& operator=(ConvexHullImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mPoints = other.mPoints;
		}
		return *this;
	}

	Vec3VectorImpl   mPoints;  									// Array of data points describing the convex hull
private:
	ConvexHull   mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
};

typedef std::vector< uint32_t > U32VectorImpl; // Forward declare the 'U32' vector
typedef std::vector< uint8_t > U8VectorImpl; // Forward declare the 'U8' vector

// Describes the data for a triangle mesh
class TriangleMeshImpl : public NodeImpl
{
public:
	// Declare the constructor.
	TriangleMeshImpl()
	{
		NodeImpl::mType = NT_TRIANGLEMESH;
	}


	// Declare the virtual destructor.
	virtual ~TriangleMeshImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	TriangleMeshImpl(const TriangleMeshImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	TriangleMesh * getTriangleMesh(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new TriangleMeshImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	TriangleMeshImpl& operator=(const TriangleMeshImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			mPoints = other.mPoints;
			mTriangles = other.mTriangles;
			mMaterialIndices = other.mMaterialIndices;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.pointsCount = uint32_t(mPoints.size()); // assign the number of items in the array.
		mDOM.points = mDOM.pointsCount ? &mPoints[0] : nullptr; // Assign the pointer array
		mDOM.trianglesCount = uint32_t(mTriangles.size()); // assign the number of items in the array.
		mDOM.triangles = mDOM.trianglesCount ? &mTriangles[0] : nullptr; // Assign the pointer array
		mDOM.materialIndicesCount = uint32_t(mMaterialIndices.size()); // assign the number of items in the array.
		mDOM.materialIndices = mDOM.materialIndicesCount ? &mMaterialIndices[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	TriangleMeshImpl(TriangleMeshImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	TriangleMeshImpl& operator=(TriangleMeshImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mPoints = other.mPoints;
			mTriangles = other.mTriangles;
			mMaterialIndices = other.mMaterialIndices;
		}
		return *this;
	}

	Vec3VectorImpl   mPoints;  									// Array of vertices for the triangle mesh
	U32VectorImpl  mTriangles;   								// Array of triangle indices
	U8VectorImpl mMaterialIndices;   							// Optional per-triangle material index
private:
	TriangleMesh mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
};

typedef std::vector< uint16_t > U16VectorImpl; // Forward declare the 'U16' vector

// The data for a heighfield; as 2d array of 32 bit samples; 16 bits for height, 16 bits for material indices, holes, and other metadata
class HeightFieldImpl : public NodeImpl
{
public:
	// Declare the constructor.
	HeightFieldImpl()
	{
		NodeImpl::mType = NT_HEIGHTFIELD;
	}


	// Declare the virtual destructor.
	virtual ~HeightFieldImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	HeightFieldImpl(const HeightFieldImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	HeightField * getHeightField(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new HeightFieldImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	HeightFieldImpl& operator=(const HeightFieldImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			mRowCount = other.mRowCount;
			mColumnCount = other.mColumnCount;
			mSamples = other.mSamples;
			mMetaData = other.mMetaData;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.rowCount = mRowCount; // Simple member variable assignment to the DOM reflection: rowCount
		mDOM.columnCount = mColumnCount; // Simple member variable assignment to the DOM reflection: columnCount
		mDOM.samplesCount = uint32_t(mSamples.size()); // assign the number of items in the array.
		mDOM.samples = mDOM.samplesCount ? &mSamples[0] : nullptr; // Assign the pointer array
		mDOM.metaDataCount = uint32_t(mMetaData.size()); // assign the number of items in the array.
		mDOM.metaData = mDOM.metaDataCount ? &mMetaData[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	HeightFieldImpl(HeightFieldImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	HeightFieldImpl& operator=(HeightFieldImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mRowCount = other.mRowCount;
			mColumnCount = other.mColumnCount;
			mSamples = other.mSamples;
			mMetaData = other.mMetaData;
		}
		return *this;
	}

	uint32_t 	mRowCount{ 0 };  									// Number of sample rows in the height field samples array.
	uint32_t 	mColumnCount{ 0 }; 								// Number of sample columns in the height field samples array.
	U16VectorImpl  mSamples; 									// Heightfield sample data
	U16VectorImpl  mMetaData;  									// Optional meta data for each sample; determines per sample material, winding order, and whether or not to treat it as a hole
private:
	HeightField	mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
};


// Base class for all geometries
class GeometryImpl: public CloneObject
{
public:

	// Declare the constructor.
	GeometryImpl() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	GeometryImpl(const GeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new GeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	GeometryImpl& operator=(const GeometryImpl& other)
	{
		if (this != &other )
		{
			mType = other.mType;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	GeometryImpl(GeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	GeometryImpl& operator=(GeometryImpl&& other)
	{
		if (this != &other )
		{
			mType = other.mType;
		}
		return *this;
	}

	GeometryType mType;											// 
private:
	Geometry 	mDOM; // Declare the DOM version.
};


// Defines a box geometry
class BoxGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	BoxGeometryImpl()
	{
		GeometryImpl::mType = GT_BOX_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~BoxGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BoxGeometryImpl(const BoxGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	BoxGeometry * getBoxGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BoxGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	BoxGeometryImpl& operator=(const BoxGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
			mDimensions = other.mDimensions;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.dimensions = mDimensions; // Simple member variable assignment to the DOM reflection: dimensions
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BoxGeometryImpl(BoxGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BoxGeometryImpl& operator=(BoxGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
			mDimensions = other.mDimensions;
		}
		return *this;
	}

	Vec3 		mDimensions{ 1,1,1 }; 								// Dimensions of the box
private:
	BoxGeometry	mDOM; // Declare the DOM version.
};


// Defines a sphere geometry
class SphereGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	SphereGeometryImpl()
	{
		GeometryImpl::mType = GT_SPHERE_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~SphereGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SphereGeometryImpl(const SphereGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	SphereGeometry * getSphereGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SphereGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	SphereGeometryImpl& operator=(const SphereGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
			mRadius = other.mRadius;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.radius = mRadius; // Simple member variable assignment to the DOM reflection: radius
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SphereGeometryImpl(SphereGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SphereGeometryImpl& operator=(SphereGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
			mRadius = other.mRadius;
		}
		return *this;
	}

	float  		mRadius{ 1 };   									// The radius of the sphere
private:
	SphereGeometry   mDOM; // Declare the DOM version.
};


// Defines a capsule geometry
class CapsuleGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	CapsuleGeometryImpl()
	{
		GeometryImpl::mType = GT_CAPSULE_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~CapsuleGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	CapsuleGeometryImpl(const CapsuleGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	CapsuleGeometry * getCapsuleGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new CapsuleGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	CapsuleGeometryImpl& operator=(const CapsuleGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
			mRadius = other.mRadius;
			mHeight = other.mHeight;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.radius = mRadius; // Simple member variable assignment to the DOM reflection: radius
		mDOM.height = mHeight; // Simple member variable assignment to the DOM reflection: height
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	CapsuleGeometryImpl(CapsuleGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	CapsuleGeometryImpl& operator=(CapsuleGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
			mRadius = other.mRadius;
			mHeight = other.mHeight;
		}
		return *this;
	}

	float  		mRadius{ 1 };   									// The radius of the capsule
	float  		mHeight{ 1 };   									// The height of the capsule
private:
	CapsuleGeometry mDOM; // Declare the DOM version.
};


// Defines a cylinder geometry
class CylinderGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	CylinderGeometryImpl()
	{
		GeometryImpl::mType = GT_CYLINDER_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~CylinderGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	CylinderGeometryImpl(const CylinderGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	CylinderGeometry * getCylinderGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new CylinderGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	CylinderGeometryImpl& operator=(const CylinderGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
			mRadius = other.mRadius;
			mHeight = other.mHeight;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.radius = mRadius; // Simple member variable assignment to the DOM reflection: radius
		mDOM.height = mHeight; // Simple member variable assignment to the DOM reflection: height
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	CylinderGeometryImpl(CylinderGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	CylinderGeometryImpl& operator=(CylinderGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
			mRadius = other.mRadius;
			mHeight = other.mHeight;
		}
		return *this;
	}

	float  		mRadius{ 1 };   									// The radius of the cylinder
	float  		mHeight{ 1 };   									// The height of the cylinder
private:
	CylinderGeometry mDOM; // Declare the DOM version.
};


// Defines a convex mesh geometry
class ConvexHullGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	ConvexHullGeometryImpl()
	{
		GeometryImpl::mType = GT_CONVEXHULL_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~ConvexHullGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	ConvexHullGeometryImpl(const ConvexHullGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	ConvexHullGeometry * getConvexHullGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new ConvexHullGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	ConvexHullGeometryImpl& operator=(const ConvexHullGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
			mScale = other.mScale;
			mConvexMesh = other.mConvexMesh;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.scale = mScale; // Simple member variable assignment to the DOM reflection: scale
		mDOM.convexMesh = mConvexMesh.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	ConvexHullGeometryImpl(ConvexHullGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	ConvexHullGeometryImpl& operator=(ConvexHullGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
			mScale = other.mScale;
			mConvexMesh = other.mConvexMesh;
		}
		return *this;
	}

	MeshScale  	mScale;											// The scale to apply to this convex mesh
	std::string	mConvexMesh; 									// The name of the convex mesh asset
private:
	ConvexHullGeometry mDOM; // Declare the DOM version.
};


// Defines a triangle mesh geometry
class TriangleMeshGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	TriangleMeshGeometryImpl()
	{
		GeometryImpl::mType = GT_TRIANGLEMESH_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~TriangleMeshGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	TriangleMeshGeometryImpl(const TriangleMeshGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	TriangleMeshGeometry * getTriangleMeshGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new TriangleMeshGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	TriangleMeshGeometryImpl& operator=(const TriangleMeshGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
			mScale = other.mScale;
			mTriangleMesh = other.mTriangleMesh;
			mDoubleSided = other.mDoubleSided;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.scale = mScale; // Simple member variable assignment to the DOM reflection: scale
		mDOM.triangleMesh = mTriangleMesh.c_str(); // Assign the current string pointer.
		mDOM.doubleSided = mDoubleSided; // Simple member variable assignment to the DOM reflection: doubleSided
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	TriangleMeshGeometryImpl(TriangleMeshGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	TriangleMeshGeometryImpl& operator=(TriangleMeshGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
			mScale = other.mScale;
			mTriangleMesh = other.mTriangleMesh;
			mDoubleSided = other.mDoubleSided;
		}
		return *this;
	}

	MeshScale  	mScale;											// The scale of the triangle mesh
	std::string	mTriangleMesh;   								// The name of the triangle mesh asset
	bool 		mDoubleSided{ false };  								// Whether or not this triangle mesh should be treated as double sided for collision detection
private:
	TriangleMeshGeometry mDOM; // Declare the DOM version.
};


// Defines a heightfield geometry
class HeightFieldGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	HeightFieldGeometryImpl()
	{
		GeometryImpl::mType = GT_HEIGHTFIELD_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~HeightFieldGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	HeightFieldGeometryImpl(const HeightFieldGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	HeightFieldGeometry * getHeightFieldGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new HeightFieldGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	HeightFieldGeometryImpl& operator=(const HeightFieldGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
			mHeightField = other.mHeightField;
			mHeightScale = other.mHeightScale;
			mRowScale = other.mRowScale;
			mColumnScale = other.mColumnScale;
			mDoubleSided = other.mDoubleSided;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.heightField = mHeightField.c_str(); // Assign the current string pointer.
		mDOM.heightScale = mHeightScale; // Simple member variable assignment to the DOM reflection: heightScale
		mDOM.rowScale = mRowScale; // Simple member variable assignment to the DOM reflection: rowScale
		mDOM.columnScale = mColumnScale; // Simple member variable assignment to the DOM reflection: columnScale
		mDOM.doubleSided = mDoubleSided; // Simple member variable assignment to the DOM reflection: doubleSided
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	HeightFieldGeometryImpl(HeightFieldGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	HeightFieldGeometryImpl& operator=(HeightFieldGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
			mHeightField = other.mHeightField;
			mHeightScale = other.mHeightScale;
			mRowScale = other.mRowScale;
			mColumnScale = other.mColumnScale;
			mDoubleSided = other.mDoubleSided;
		}
		return *this;
	}

	std::string	mHeightField;  									// The id of the heightfield data asset
	float  		mHeightScale{ 1 };									// The scaling factor for the height field in vertical direction (y direction in local space).
	float  		mRowScale{ 1 }; 									// The scaling factor for the height field in the row direction (x direction in local space).
	float  		mColumnScale{ 1 };									// The scaling factor for the height field in the column direction (z direction in local space).
	bool 		mDoubleSided{ false };  								// Whether or not this heighfield should be treated as double sided for collision detection
private:
	HeightFieldGeometry mDOM; // Declare the DOM version.
};


// Defines a plane equation geometry (position and orientation of the plane come from the geometry instance)
class PlaneGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	PlaneGeometryImpl()
	{
		GeometryImpl::mType = GT_PLANE_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~PlaneGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PlaneGeometryImpl(const PlaneGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	PlaneGeometry * getPlaneGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new PlaneGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	PlaneGeometryImpl& operator=(const PlaneGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PlaneGeometryImpl(PlaneGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PlaneGeometryImpl& operator=(PlaneGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
		}
		return *this;
	}

private:
	PlaneGeometry  mDOM; // Declare the DOM version.
};


// Defines a single instance of a geometry
class GeometryInstanceImpl: public CloneObject
{
public:

	// Declare the constructor.
	GeometryInstanceImpl() { }


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~GeometryInstanceImpl()
	{
		delete mGeometry; // Delete this object
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	GeometryInstanceImpl(const GeometryInstanceImpl &other)
	{
		*this = other;
	}


	virtual GeometryInstance * getGeometryInstance(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new GeometryInstanceImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	GeometryInstanceImpl& operator=(const GeometryInstanceImpl& other)
	{
		if (this != &other )
		{
			delete mGeometry; // delete any previous pointer.
			mGeometry = nullptr; // set the pointer to null.
			if ( other.mGeometry )
			{
				mGeometry = static_cast<GeometryImpl *>(other.mGeometry->clone()); // perform the deep copy and assignment here
			}
			mMaterials = other.mMaterials;
			mLocalPose = other.mLocalPose;
			mCollisionFilterSettings = other.mCollisionFilterSettings;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		if ( mGeometry )
		{
			mGeometry->initDOM(); // Initialize any DOM components of this object.
			mDOM.geometry = mGeometry->getGeometry(); // assign the DOM reflection pointer.
		}
		// Initialize the const char * array from the array of std::strings vector mMaterials
		mMaterialsImpl.reserve(mMaterials.size()); // Reserve room for string pointers.
		for (auto &i: mMaterials) // For each std::string
			mMaterialsImpl.push_back( i.c_str() ); // Add the const char * for the string.
		mDOM.materialsCount = uint32_t(mMaterialsImpl.size()); // Assign the number of strings
		mDOM.materials = mDOM.materialsCount ? &mMaterialsImpl[0] : nullptr; // Assign the pointer array.
		mDOM.localPose = mLocalPose; // Simple member variable assignment to the DOM reflection: localPose
		mDOM.collisionFilterSettings = mCollisionFilterSettings.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	GeometryInstanceImpl(GeometryInstanceImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	GeometryInstanceImpl& operator=(GeometryInstanceImpl&& other)
	{
		if (this != &other )
		{
			mGeometry = other.mGeometry;
			other.mGeometry = nullptr; // Set 'other' pointer to null since we have moved it
			mMaterials = other.mMaterials;
			mLocalPose = other.mLocalPose;
			mCollisionFilterSettings = other.mCollisionFilterSettings;
		}
		return *this;
	}

	GeometryImpl *mGeometry{ nullptr };							// The geometry associated with this instance
	StringVector mMaterials; 									// Id of physical material(s) associated with this geometry instance (usually one material; but for heightifields and triangle meshes can be more than one)
	Pose 		mLocalPose;   										// The local pose for this geometry instance
	std::string	mCollisionFilterSettings;  						// Describes collision filtering settings; what other types of objects this object will collide with
private:
	GeometryInstance mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	ConstCharVector mMaterialsImpl; // Scratch array for const char pointers.
};

typedef std::vector< GeometryInstanceImpl *> GeometryInstanceVectorImpl; // Forward declare the 'GeometryInstance' vector for the implementation object pointers
typedef std::vector< GeometryInstance *> GeometryInstanceVectorDOM; // Forward declare the 'GeometryInstance' vector for the implementation object pointers

// Defines the common properties for a rigid body
class RigidBodyImpl : public NodeImpl
{
public:
	// Declare the constructor.
	RigidBodyImpl()
	{
		NodeImpl::mType = NT_RIGID_BODY;
	}


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~RigidBodyImpl()
	{
		for (auto &i:mGeometryInstances) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RigidBodyImpl(const RigidBodyImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	RigidBody * getRigidBody(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RigidBodyImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	RigidBodyImpl& operator=(const RigidBodyImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			for (auto &i:mGeometryInstances) delete i; // Delete all of the object pointers in this array
			mGeometryInstances.clear(); // Clear the current array
			mGeometryInstances.reserve(other.mGeometryInstances.size()); // Reserve number of items for the new array
			for (auto &i:other.mGeometryInstances) mGeometryInstances.push_back( static_cast< GeometryInstanceImpl *>(i->clone())); // Deep copy object pointers into the array
			mGlobalPose = other.mGlobalPose;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mGeometryInstancesDOM.clear();
		mGeometryInstancesDOM.reserve( mGeometryInstances.size() );
		for (auto &i:mGeometryInstances)
		{
			i->initDOM();
			mGeometryInstancesDOM.push_back( i->getGeometryInstance() );
		}
		mDOM.geometryInstancesCount = uint32_t(mGeometryInstancesDOM.size()); // assign the number of items in the array.
		mDOM.geometryInstances = mDOM.geometryInstancesCount ? &mGeometryInstancesDOM[0] : nullptr; // Assign the pointer array
		mDOM.globalPose = mGlobalPose; // Simple member variable assignment to the DOM reflection: globalPose
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RigidBodyImpl(RigidBodyImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RigidBodyImpl& operator=(RigidBodyImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mGeometryInstances = other.mGeometryInstances;
			other.mGeometryInstances.clear(); // Clear the 'other' array now that we have moved it
			mGlobalPose = other.mGlobalPose;
		}
		return *this;
	}

	GeometryInstanceVectorImpl mGeometryInstances;   			// The set of geometries to instance with this actor
	Pose 		mGlobalPose;											// The global pose for this actor
private:
	RigidBody  	mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	GeometryInstanceVectorDOM mGeometryInstancesDOM; // Scratch array for const char pointers.
};


// Defines a static rigid body
class RigidStaticImpl : public RigidBodyImpl
{
public:
	// Declare the constructor.
	RigidStaticImpl()
	{
		NodeImpl::mType = NT_RIGID_STATIC;
	}


	// Declare the virtual destructor.
	virtual ~RigidStaticImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RigidStaticImpl(const RigidStaticImpl &other)
	{
		*this = other;
	}


	virtual RigidBody * getRigidBody(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< RigidBody *>(&mDOM); // return the address of the DOM.
	}


	RigidStatic * getRigidStatic(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RigidStaticImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	RigidStaticImpl& operator=(const RigidStaticImpl& other)
	{
		if (this != &other )
		{
			RigidBodyImpl::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		RigidBodyImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			RigidBody *dom = static_cast< RigidBody *>(&mDOM); // Get the DOM base class.
			*dom = *(RigidBodyImpl::getRigidBody()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RigidStaticImpl(RigidStaticImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RigidStaticImpl& operator=(RigidStaticImpl&& other)
	{
		if (this != &other )
		{
			RigidBodyImpl::operator=(std::move(other));
		}
		return *this;
	}

private:
	RigidStatic	mDOM; // Declare the DOM version.
};


// Defines a dynamic rigid body
class RigidDynamicImpl : public RigidBodyImpl
{
public:
	// Declare the constructor.
	RigidDynamicImpl()
	{
		NodeImpl::mType = NT_RIGID_DYNAMIC;
	}


	// Declare the virtual destructor.
	virtual ~RigidDynamicImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RigidDynamicImpl(const RigidDynamicImpl &other)
	{
		*this = other;
	}


	virtual RigidBody * getRigidBody(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< RigidBody *>(&mDOM); // return the address of the DOM.
	}


	RigidDynamic * getRigidDynamic(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RigidDynamicImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	RigidDynamicImpl& operator=(const RigidDynamicImpl& other)
	{
		if (this != &other )
		{
			RigidBodyImpl::operator=(other);
			mDisableGravity = other.mDisableGravity;
			mCenterOfMassLocalPose = other.mCenterOfMassLocalPose;
			mMass = other.mMass;
			mMassSpaceInertiaTensor = other.mMassSpaceInertiaTensor;
			mLinearVelocity = other.mLinearVelocity;
			mAngularVelocity = other.mAngularVelocity;
			mLinearDamping = other.mLinearDamping;
			mAngularDamping = other.mAngularDamping;
			mMaxAngularVelocity = other.mMaxAngularVelocity;
			mKinematic = other.mKinematic;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		RigidBodyImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			RigidBody *dom = static_cast< RigidBody *>(&mDOM); // Get the DOM base class.
			*dom = *(RigidBodyImpl::getRigidBody()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.disableGravity = mDisableGravity; // Simple member variable assignment to the DOM reflection: disableGravity
		mDOM.centerOfMassLocalPose = mCenterOfMassLocalPose; // Simple member variable assignment to the DOM reflection: centerOfMassLocalPose
		mDOM.mass = mMass; // Simple member variable assignment to the DOM reflection: mass
		mDOM.massSpaceInertiaTensor = mMassSpaceInertiaTensor; // Simple member variable assignment to the DOM reflection: massSpaceInertiaTensor
		mDOM.linearVelocity = mLinearVelocity; // Simple member variable assignment to the DOM reflection: linearVelocity
		mDOM.angularVelocity = mAngularVelocity; // Simple member variable assignment to the DOM reflection: angularVelocity
		mDOM.linearDamping = mLinearDamping; // Simple member variable assignment to the DOM reflection: linearDamping
		mDOM.angularDamping = mAngularDamping; // Simple member variable assignment to the DOM reflection: angularDamping
		mDOM.maxAngularVelocity = mMaxAngularVelocity; // Simple member variable assignment to the DOM reflection: maxAngularVelocity
		mDOM.kinematic = mKinematic; // Simple member variable assignment to the DOM reflection: kinematic
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RigidDynamicImpl(RigidDynamicImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RigidDynamicImpl& operator=(RigidDynamicImpl&& other)
	{
		if (this != &other )
		{
			RigidBodyImpl::operator=(std::move(other));
			mDisableGravity = other.mDisableGravity;
			mCenterOfMassLocalPose = other.mCenterOfMassLocalPose;
			mMass = other.mMass;
			mMassSpaceInertiaTensor = other.mMassSpaceInertiaTensor;
			mLinearVelocity = other.mLinearVelocity;
			mAngularVelocity = other.mAngularVelocity;
			mLinearDamping = other.mLinearDamping;
			mAngularDamping = other.mAngularDamping;
			mMaxAngularVelocity = other.mMaxAngularVelocity;
			mKinematic = other.mKinematic;
		}
		return *this;
	}

	bool 		mDisableGravity{ false }; 							// Disables scene gravity for this actor
	Pose 		mCenterOfMassLocalPose;   							// Center of mass and local pose
	float  		mMass{ 1 }; 										// Sets the mass of a dynamic actor.
	Vec3 		mMassSpaceInertiaTensor{ 1,1,1 }; 					// Sets the inertia tensor, using a parameter specified in mass space coordinates.
	Vec3 		mLinearVelocity{ 0,0,0 }; 							// Sets the linear velocity of the actor.
	Vec3 		mAngularVelocity{ 0,0,0 };  							// Sets the angular velocity of the actor.
	float  		mLinearDamping{ 0 };  								// Sets the linear damping coefficient.
	float  		mAngularDamping{ 0.05f };   						// Sets the angular damping coefficient.
	float  		mMaxAngularVelocity{ 7 };   						// set the maximum angular velocity permitted for this actor.
	bool 		mKinematic{ false };									// If true this is a dynamic object; but currently kinematically controlled
private:
	RigidDynamic mDOM; // Declare the DOM version.
};


// Defines the common properties for a joint
class JointImpl : public NodeImpl
{
public:
	// Declare the constructor.
	JointImpl()
	{
		NodeImpl::mType = NT_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~JointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	JointImpl(const JointImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	Joint * getJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new JointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	JointImpl& operator=(const JointImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			mBody0 = other.mBody0;
			mBody1 = other.mBody1;
			mLocalpose0 = other.mLocalpose0;
			mLocalpose1 = other.mLocalpose1;
			mCollisionEnabled = other.mCollisionEnabled;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.body0 = mBody0.c_str(); // Assign the current string pointer.
		mDOM.body1 = mBody1.c_str(); // Assign the current string pointer.
		mDOM.localpose0 = mLocalpose0; // Simple member variable assignment to the DOM reflection: localpose0
		mDOM.localpose1 = mLocalpose1; // Simple member variable assignment to the DOM reflection: localpose1
		mDOM.collisionEnabled = mCollisionEnabled; // Simple member variable assignment to the DOM reflection: collisionEnabled
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	JointImpl(JointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	JointImpl& operator=(JointImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mBody0 = other.mBody0;
			mBody1 = other.mBody1;
			mLocalpose0 = other.mLocalpose0;
			mLocalpose1 = other.mLocalpose1;
			mCollisionEnabled = other.mCollisionEnabled;
		}
		return *this;
	}

	std::string	mBody0;											// Id of first rigid body joint is constrained to; if empty string; then constaint to the world
	std::string	mBody1;											// Id of the second rigid body the joint is constrainted to
	Pose 		mLocalpose0;											// The parent relative pose; relative to body0
	Pose 		mLocalpose1;											// The parent relative pose; relative to body1
	bool 		mCollisionEnabled{ false };   						// 
private:
	Joint  		mDOM; // Declare the DOM version.
};


// Defines the properties specific to a fixed joint 
// Not all properties yet defined!
class FixedJointImpl : public JointImpl
{
public:
	// Declare the constructor.
	FixedJointImpl()
	{
		JointImpl::mType = NT_FIXED_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~FixedJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	FixedJointImpl(const FixedJointImpl &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Joint *>(&mDOM); // return the address of the DOM.
	}


	FixedJoint * getFixedJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new FixedJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	FixedJointImpl& operator=(const FixedJointImpl& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointImpl::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	FixedJointImpl(FixedJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	FixedJointImpl& operator=(FixedJointImpl&& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(std::move(other));
		}
		return *this;
	}

private:
	FixedJoint   mDOM; // Declare the DOM version.
};


// Defines the properties specific to a spherical joint 
// Not all properties yet defined!
class SphericalJointImpl : public JointImpl
{
public:
	// Declare the constructor.
	SphericalJointImpl()
	{
		JointImpl::mType = NT_SPHERICAL_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~SphericalJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SphericalJointImpl(const SphericalJointImpl &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Joint *>(&mDOM); // return the address of the DOM.
	}


	SphericalJoint * getSphericalJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SphericalJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	SphericalJointImpl& operator=(const SphericalJointImpl& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointImpl::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SphericalJointImpl(SphericalJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SphericalJointImpl& operator=(SphericalJointImpl&& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(std::move(other));
		}
		return *this;
	}

private:
	SphericalJoint   mDOM; // Declare the DOM version.
};


// Defines the properties specific to a revolute joint 
// Not all properties yet defined!
class RevoluteJointImpl : public JointImpl
{
public:
	// Declare the constructor.
	RevoluteJointImpl()
	{
		JointImpl::mType = NT_REVOLUTE_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~RevoluteJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RevoluteJointImpl(const RevoluteJointImpl &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Joint *>(&mDOM); // return the address of the DOM.
	}


	RevoluteJoint * getRevoluteJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RevoluteJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	RevoluteJointImpl& operator=(const RevoluteJointImpl& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointImpl::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RevoluteJointImpl(RevoluteJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RevoluteJointImpl& operator=(RevoluteJointImpl&& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(std::move(other));
		}
		return *this;
	}

private:
	RevoluteJoint  mDOM; // Declare the DOM version.
};


// Defines the properties specific to a prismatic joint 
// Not all properties yet defined!
class PrismaticJointImpl : public JointImpl
{
public:
	// Declare the constructor.
	PrismaticJointImpl()
	{
		JointImpl::mType = NT_PRISMATIC_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~PrismaticJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PrismaticJointImpl(const PrismaticJointImpl &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Joint *>(&mDOM); // return the address of the DOM.
	}


	PrismaticJoint * getPrismaticJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new PrismaticJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	PrismaticJointImpl& operator=(const PrismaticJointImpl& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointImpl::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PrismaticJointImpl(PrismaticJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PrismaticJointImpl& operator=(PrismaticJointImpl&& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(std::move(other));
		}
		return *this;
	}

private:
	PrismaticJoint   mDOM; // Declare the DOM version.
};


// Defines the properties specific to a distance joint 
// Not all properties yet defined!
class DistanceJointImpl : public JointImpl
{
public:
	// Declare the constructor.
	DistanceJointImpl()
	{
		JointImpl::mType = NT_DISTANCE_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~DistanceJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	DistanceJointImpl(const DistanceJointImpl &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Joint *>(&mDOM); // return the address of the DOM.
	}


	DistanceJoint * getDistanceJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new DistanceJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	DistanceJointImpl& operator=(const DistanceJointImpl& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointImpl::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	DistanceJointImpl(DistanceJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	DistanceJointImpl& operator=(DistanceJointImpl&& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(std::move(other));
		}
		return *this;
	}

private:
	DistanceJoint  mDOM; // Declare the DOM version.
};


// Defines the properties specific to a ball and socket joint 
// Not all properties yet defined!
class BallAndSocketJointImpl : public JointImpl
{
public:
	// Declare the constructor.
	BallAndSocketJointImpl()
	{
		JointImpl::mType = NT_BALL_AND_SOCKET_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~BallAndSocketJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BallAndSocketJointImpl(const BallAndSocketJointImpl &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Joint *>(&mDOM); // return the address of the DOM.
	}


	BallAndSocketJoint * getBallAndSocketJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BallAndSocketJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	BallAndSocketJointImpl& operator=(const BallAndSocketJointImpl& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointImpl::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BallAndSocketJointImpl(BallAndSocketJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BallAndSocketJointImpl& operator=(BallAndSocketJointImpl&& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(std::move(other));
		}
		return *this;
	}

private:
	BallAndSocketJoint mDOM; // Declare the DOM version.
};


// Defines the properties specific to a six degree of freedom joint 
// Not all properties yet defined!
class D6JointImpl : public JointImpl
{
public:
	// Declare the constructor.
	D6JointImpl()
	{
		JointImpl::mType = NT_D6_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~D6JointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	D6JointImpl(const D6JointImpl &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Joint *>(&mDOM); // return the address of the DOM.
	}


	D6Joint * getD6Joint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new D6JointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	D6JointImpl& operator=(const D6JointImpl& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointImpl::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	D6JointImpl(D6JointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	D6JointImpl& operator=(D6JointImpl&& other)
	{
		if (this != &other )
		{
			JointImpl::operator=(std::move(other));
		}
		return *this;
	}

private:
	D6Joint		mDOM; // Declare the DOM version.
};


// Defines two bodies, by id, that should not collide with each other
class BodyPairFilterImpl: public CloneObject
{
public:

	// Declare the constructor.
	BodyPairFilterImpl() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BodyPairFilterImpl(const BodyPairFilterImpl &other)
	{
		*this = other;
	}


	virtual BodyPairFilter * getBodyPairFilter(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new BodyPairFilterImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	BodyPairFilterImpl& operator=(const BodyPairFilterImpl& other)
	{
		if (this != &other )
		{
			mBodyA = other.mBodyA;
			mBodyB  = other.mBodyB ;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.bodyA = mBodyA.c_str(); // Assign the current string pointer.
		mDOM.bodyB  = mBodyB .c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BodyPairFilterImpl(BodyPairFilterImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BodyPairFilterImpl& operator=(BodyPairFilterImpl&& other)
	{
		if (this != &other )
		{
			mBodyA = other.mBodyA;
			mBodyB  = other.mBodyB ;
		}
		return *this;
	}

	std::string	mBodyA;											// Id of first body
	std::string	mBodyB ; 										// Id of second body
private:
	BodyPairFilter   mDOM; // Declare the DOM version.
};

typedef std::vector< BodyPairFilterImpl > BodyPairFilterVectorImpl; // Forward declare the 'BodyPairFilter' vector
typedef std::vector< BodyPairFilter > BodyPairFilterVectorDOM; // Forward declare the 'BodyPairFilter' vector

// A collection of body pair filters
class BodyPairFiltersImpl : public NodeImpl
{
public:
	// Declare the constructor.
	BodyPairFiltersImpl()
	{
		NodeImpl::mType = NT_BODY_PAIR_FILTERS;
	}


	// Declare the virtual destructor.
	virtual ~BodyPairFiltersImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BodyPairFiltersImpl(const BodyPairFiltersImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	BodyPairFilters * getBodyPairFilters(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BodyPairFiltersImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	BodyPairFiltersImpl& operator=(const BodyPairFiltersImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			mBodyPairs = other.mBodyPairs;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.bodyPairsCount = uint32_t(mBodyPairsDOM.size()); // assign the number of items in the array.
		mDOM.bodyPairs = mDOM.bodyPairsCount ? &mBodyPairsDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BodyPairFiltersImpl(BodyPairFiltersImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BodyPairFiltersImpl& operator=(BodyPairFiltersImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mBodyPairs = other.mBodyPairs;
		}
		return *this;
	}

	BodyPairFilterVectorImpl mBodyPairs; 						// Array of body pair filters
private:
	BodyPairFilters mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	BodyPairFilterVectorDOM mBodyPairsDOM; // Scratch array for const char pointers.
};


class InstanceCollectionImpl : public NodeImpl
{
public:
	// Declare the constructor.
	InstanceCollectionImpl()
	{
		NodeImpl::mType = NT_INSTANCE_COLLECTION;
	}


	// Declare the virtual destructor.
	virtual ~InstanceCollectionImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	InstanceCollectionImpl(const InstanceCollectionImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	InstanceCollection * getInstanceCollection(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new InstanceCollectionImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	InstanceCollectionImpl& operator=(const InstanceCollectionImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			mCollection = other.mCollection;
			mPose = other.mPose;
			mScale = other.mScale;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.collection = mCollection.c_str(); // Assign the current string pointer.
		mDOM.pose = mPose; // Simple member variable assignment to the DOM reflection: pose
		mDOM.scale = mScale; // Simple member variable assignment to the DOM reflection: scale
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	InstanceCollectionImpl(InstanceCollectionImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	InstanceCollectionImpl& operator=(InstanceCollectionImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mCollection = other.mCollection;
			mPose = other.mPose;
			mScale = other.mScale;
		}
		return *this;
	}

	std::string	mCollection; 									// Name of collection to instance
	Pose 		mPose;  												// Pose to instance collection at
	Vec3 		mScale;   											// Scale of instance
private:
	InstanceCollection mDOM; // Declare the DOM version.
};

typedef std::vector< NodeImpl *> NodeVectorImpl; // Forward declare the 'Node' vector for the implementation object pointers
typedef std::vector< Node *> NodeVectorDOM; // Forward declare the 'Node' vector for the implementation object pointers

// A collection of nodes
class CollectionImpl : public NodeImpl
{
public:
	// Declare the constructor.
	CollectionImpl()
	{
		NodeImpl::mType = NT_COLLECTION;
	}


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~CollectionImpl()
	{
		for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	CollectionImpl(const CollectionImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	Collection * getCollection(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new CollectionImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	CollectionImpl& operator=(const CollectionImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
			mNodes.clear(); // Clear the current array
			mNodes.reserve(other.mNodes.size()); // Reserve number of items for the new array
			for (auto &i:other.mNodes) mNodes.push_back( static_cast< NodeImpl *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mNodesDOM.clear();
		mNodesDOM.reserve( mNodes.size() );
		for (auto &i:mNodes)
		{
			i->initDOM();
			mNodesDOM.push_back( i->getNode() );
		}
		mDOM.nodesCount = uint32_t(mNodesDOM.size()); // assign the number of items in the array.
		mDOM.nodes = mDOM.nodesCount ? &mNodesDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	CollectionImpl(CollectionImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	CollectionImpl& operator=(CollectionImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mNodes = other.mNodes;
			other.mNodes.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	NodeVectorImpl   mNodes; 									// Array of nodes in this collection
private:
	Collection   mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	NodeVectorDOM  mNodesDOM; // Scratch array for const char pointers.
};


// A special type of 'collection' which is instantiated on startup
class SceneImpl : public NodeImpl
{
public:
	// Declare the constructor.
	SceneImpl()
	{
		NodeImpl::mType = NT_SCENE;
	}


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~SceneImpl()
	{
		for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SceneImpl(const SceneImpl &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Node *>(&mDOM); // return the address of the DOM.
	}


	Scene * getScene(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SceneImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	SceneImpl& operator=(const SceneImpl& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(other);
			mGravity = other.mGravity;
			for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
			mNodes.clear(); // Clear the current array
			mNodes.reserve(other.mNodes.size()); // Reserve number of items for the new array
			for (auto &i:other.mNodes) mNodes.push_back( static_cast< NodeImpl *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeImpl::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.gravity = mGravity; // Simple member variable assignment to the DOM reflection: gravity
		mNodesDOM.clear();
		mNodesDOM.reserve( mNodes.size() );
		for (auto &i:mNodes)
		{
			i->initDOM();
			mNodesDOM.push_back( i->getNode() );
		}
		mDOM.nodesCount = uint32_t(mNodesDOM.size()); // assign the number of items in the array.
		mDOM.nodes = mDOM.nodesCount ? &mNodesDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SceneImpl(SceneImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SceneImpl& operator=(SceneImpl&& other)
	{
		if (this != &other )
		{
			NodeImpl::operator=(std::move(other));
			mGravity = other.mGravity;
			mNodes = other.mNodes;
			other.mNodes.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	Vec3 		mGravity{ 0.0f,-9.8f,0.0f };							// Gravity
	NodeVectorImpl   mNodes; 									// Array of nodes in this collection
private:
	Scene  		mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	NodeVectorDOM  mNodesDOM; // Scratch array for const char pointers.
};

typedef std::vector< CollectionImpl *> CollectionVectorImpl; // Forward declare the 'Collection' vector for the implementation object pointers
typedef std::vector< Collection *> CollectionVectorDOM; // Forward declare the 'Collection' vector for the implementation object pointers
typedef std::vector< SceneImpl *> SceneVectorImpl; // Forward declare the 'Scene' vector for the implementation object pointers
typedef std::vector< Scene *> SceneVectorDOM; // Forward declare the 'Scene' vector for the implementation object pointers

// The root node container
class PhysicsDOMImpl: public CloneObject
{
public:

	// Declare the constructor.
	PhysicsDOMImpl() { }


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~PhysicsDOMImpl()
	{
		for (auto &i:mCollections) delete i; // Delete all of the object pointers in this array
		for (auto &i:mScenes) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PhysicsDOMImpl(const PhysicsDOMImpl &other)
	{
		*this = other;
	}


	virtual PhysicsDOM * getPhysicsDOM(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new PhysicsDOMImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	PhysicsDOMImpl& operator=(const PhysicsDOMImpl& other)
	{
		if (this != &other )
		{
			for (auto &i:mCollections) delete i; // Delete all of the object pointers in this array
			mCollections.clear(); // Clear the current array
			mCollections.reserve(other.mCollections.size()); // Reserve number of items for the new array
			for (auto &i:other.mCollections) mCollections.push_back( static_cast< CollectionImpl *>(i->clone())); // Deep copy object pointers into the array
			for (auto &i:mScenes) delete i; // Delete all of the object pointers in this array
			mScenes.clear(); // Clear the current array
			mScenes.reserve(other.mScenes.size()); // Reserve number of items for the new array
			for (auto &i:other.mScenes) mScenes.push_back( static_cast< SceneImpl *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mCollectionsDOM.clear();
		mCollectionsDOM.reserve( mCollections.size() );
		for (auto &i:mCollections)
		{
			i->initDOM();
			mCollectionsDOM.push_back( i->getCollection() );
		}
		mDOM.collectionsCount = uint32_t(mCollectionsDOM.size()); // assign the number of items in the array.
		mDOM.collections = mDOM.collectionsCount ? &mCollectionsDOM[0] : nullptr; // Assign the pointer array
		mScenesDOM.clear();
		mScenesDOM.reserve( mScenes.size() );
		for (auto &i:mScenes)
		{
			i->initDOM();
			mScenesDOM.push_back( i->getScene() );
		}
		mDOM.scenesCount = uint32_t(mScenesDOM.size()); // assign the number of items in the array.
		mDOM.scenes = mDOM.scenesCount ? &mScenesDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PhysicsDOMImpl(PhysicsDOMImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PhysicsDOMImpl& operator=(PhysicsDOMImpl&& other)
	{
		if (this != &other )
		{
			mCollections = other.mCollections;
			other.mCollections.clear(); // Clear the 'other' array now that we have moved it
			mScenes = other.mScenes;
			other.mScenes.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	CollectionVectorImpl mCollections;   						// The array of top level collections
	SceneVectorImpl mScenes; 									// The array of top level scenes; a scene is instantiated into the physics simulation
private:
	PhysicsDOM   mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	CollectionVectorDOM mCollectionsDOM; // Scratch array for const char pointers.
	SceneVectorDOM   mScenesDOM; // Scratch array for const char pointers.
};



} // End of PHYSICS_DOM namespace

#endif // End of Scene
